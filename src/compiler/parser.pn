class TokenList() {
    var _items: Array<SyntaxToken> = new SyntaxToken[0]
    var _size = 0


    def ensure_capacity(count: int): unit = {
        if (_size + count >= _items.Length) {
            var newItems = new SyntaxToken[(_size + count) * 2]
            for (i <- 0 to _size) {
                newItems[i] = _items[i]
            }
            _items = newItems
        } else {
            ()
        }
    }

    def add(token: SyntaxToken): unit = {
        ensure_capacity(1)
        _items[_size] = token
        _size = _size + 1
    }

    def tokens(): Array<SyntaxToken> = {
        var newItems = new SyntaxToken[_size]
        for (i <- 0 to _size) {
            newItems[i] = _items[i]
        }
        newItems
    }
}


class Parser(source_file: SourceFile, diagnostics: DiagnosticBag) {

    val _tokens: Array<SyntaxToken> = {
        val scanner = new Scanner(source_file, diagnostics)
        val tokenList = new TokenList()
        while (true) {
            val token = scanner.scan()
            tokenList.add(token)

            if (token.kind == SyntaxKind.EndOfInputToken)
            {
                break
            } else {
                
            }
        }
        tokenList.tokens()
    }
    var _position = 0

    def next(): unit = {
        _position = _position + 1
    }

    def current(): SyntaxToken = {
        val len = _tokens.Length

        if (_position >= len) _tokens[len - 1]
        else _tokens[_position]
    }

    def accept(): SyntaxToken = {
        val token = current()
        next()
        token
    }

    def accept(kind: int): SyntaxToken = {
        val curr = current()
        if (curr.kind == kind) {
            accept()
        } else {
            diagnostics.report_unexpected_token(curr.location, curr.kind, kind)
            new SyntaxToken(source_file, kind, curr.start, "", new SyntaxTrivia[0], new SyntaxTrivia[0])
        }
    }

    def parse_namespace_declaration(): Array<NamespaceDeclarationSyntax> = {
        new NamespaceDeclarationSyntax[0]
    }

    def parse_usings(): Array<UsingDirectiveSyntax> = {
        new UsingDirectiveSyntax[0]
    }

    def parse_members():Array<MemberSyntax> = {
        new MemberSyntax[0]
    }

    def parse_compilation_unit(): CompilationUnitSyntax = {
        val namespaceDeclaration = parse_namespace_declaration()
        val usingDirectives = parse_usings()
        val members = parse_members()
        val endToken = accept(SyntaxKind.EndOfInputToken)
        new CompilationUnitSyntax(namespaceDeclaration, usingDirectives, members, endToken)
    }
}