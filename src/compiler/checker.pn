object TypeSchemeKind {
    val Polymorphic = 1
    val Simple = 2
}

class TypeScheme(kind: int, polymorphic: Array<PolymorphicType>, simple: Array<SimpleType>)

class PolymorphicType(body: SimpleType)

object SimpleTypeKind {
    val Variable = 1
    val Concrete = 2
}
class SimpleType(kind: int, variable: Array<Variable>, concrete: Array<ConcreteType>) {
    def is_any(): bool = kind == SimpleTypeKind.Concrete && concrete[0].kind == ConcreteTypeKind.Any
    def is_nothing(): bool = kind == SimpleTypeKind.Concrete && concrete[0].kind == ConcreteTypeKind.Nothing
}

object ConcreteTypeKind {
    val Any = 1 // Top
    val Nothing = 2 // Bottom
    val Function = 3
    val Record = 4
    val Primitive = 5
}

class ConcreteType(
    kind: int,
    function: Array<Function>,
    record: Array<Record>,
    primitive: Array<Primitive>,
    variable: Array<Variable>
)

class Function(params: Array<SimpleType>, returnType: SimpleType)
class RecordField(name: string, type: SimpleType)
class Record(fields: Array<RecordField>)
class Primitive(name: string)
class Variable(lower: ConcreteType, upper: ConcreteType) {
    def lower_bound(): SimpleType = {}
    def upper_bound(): SimpleType = { panic() }
    def as_type_var(): Type = {}
}

// Any is Top (super type of all types)
// Nothing is Bottom (sub type of all types)

// https://github.com/LPTK/simpler-sub/blob/simpler-sub/shared/src/main/scala/simplesub/Typer.scala

// ∩ == intersection
// ∪ == union
//
// https://www.youtube.com/watch?v=d10q-b8jNKg
// x gets type variable A
// y gets type variable B

// union of branches gets type variable C

// constraint: A <= int
// constraint: B <= int
// constraint: A, B <= C

// f: A -> B -> C where A <= int, B <= int, A ∪ B <= C
// then (coalesce bounds)
// f: A ∩ int -> B ∩ int -> A ∪ B ∪ C
// then simplify variables
// f: A ∩ int -> A ∩ int -> A

class SymbolLinks() {
    var _type: Array<Type> = new Type[0]

    def set_type(typ: Type): Type = {
        _type = new Type[] { typ }
        typ
    }

    def has_type(): bool = _type.Length > 0
    def get_type(): Type = _type[0]
}

// will be connected to a Declaration or an Expression
class NodeLinks() {
    var _type: Array<Type> = new Type[0]

    def set_type(typ: Type): Type = {
        _type = new Type[] { typ }
        typ
    }

    def has_type(): bool = _type.Length > 0
    def get_type(): Type = _type[0]
}

class Checker() {

    val BoolType: Type = MakeType.primitive("bool")
    val CharType: Type = MakeType.primitive("char")
    val IntType: Type = MakeType.primitive("int")
    val ErrorType: Type = MakeType.primitive("err")
    val StringType: Type = MakeType.primitive("string")
    val UnitType: Type = MakeType.primitive("unit")

    val Any = new ConcreteType(
        ConcreteTypeKind.Any,
        new Function[0],
        new Record[0],
        new Primitive[0],
        new Variable[0]
    )

    val Nothing = new ConcreteType(
        ConcreteTypeKind.Nothing,
        new Function[0],
        new Record[0],
        new Primitive[0],
        new Variable[0]
    )

    var last_symbol_id = 0
    var symbol_links = new SymbolLinks[10]
    var last_node_id = 0
    var node_links = new NodeLinks[10]

    def infer_types(root: Symbol): unit = {

    }

    def fresh_var(): Variable = new Variable(Nothing, Any)

    def get_type_of_symbol(symbol: Symbol): Type = {
        val links = get_symbol_links(symbol)
        if (links.has_type()) {
            links.get_type()
        } else if (symbol.has_declaration()) {
            val decl = symbol.declaration()
            val node_links = get_node_links(MakeNode.decl(decl))
            if (node_links.has_type()) {
                node_links.get_type()
            } else {
                val type = get_type_of_declaration(decl)
                node_links.set_type(type)
                links.set_type(type)
            }
        } else {
            panic("get_type_of_symbol: no declaration")
            ErrorType
        }
    }

    def get_type_of_node(node: Node): Type = {
        if (node.is_decl()) {
            get_type_of_declaration(node.declaration[0])
        } else {
            get_type_of_expression(node.expression[0])
        }
    }

    def get_type_of_declaration(decl: Declaration): Type = {
        if (decl.kind == DeclarationKind.Object) {
            get_type_of_object_declaration(decl.object_declaration[0])
        } else if (decl.kind == DeclarationKind.Class) {
            get_type_of_class_declaration(decl.class_declaration[0])
        } else if (decl.kind == DeclarationKind.Method) {
            get_type_of_method_declaration(decl.function_declaration[0])
        } else if (decl.kind == DeclarationKind.Parameter) {
            get_type_of_parameter_declaration(decl.parameter_declaration[0])
        } else if (decl.kind == DeclarationKind.Local) {
            get_type_of_local_declaration(decl.local_declaration[0])
        } else if (decl.kind == DeclarationKind.Token) {
            get_type_of_token(decl.token_declaration[0])
        } else {
            panic("get_type_of_declaration")
            ErrorType
        }
    }

    def get_type_of_object_declaration(decl: ObjectDeclarationSyntax): Type = {
        panic("get_type_of_object_declaration")
        ErrorType
    }

    def get_type_of_class_declaration(decl: ClassDeclarationSyntax): Type = {
        panic("get_type_of_class_declaration")
        ErrorType
    }

    def get_type_of_method_declaration(decl: FunctionDeclarationSyntax): Type = {
        panic("get_type_of_method_declaration")
        ErrorType
    }

    def get_type_of_parameter_declaration(decl: ParameterSyntax): Type =
        get_type_of_type_annotation(decl.typeAnnotation)

    def get_type_of_local_declaration(decl: VariableDeclarationStatementSyntax): Type = {
        // check type annotation first
        if (decl.typeAnnotation.Length > 0) {
            get_type_of_type_annotation(decl.typeAnnotation[0])
        } else {
            get_type_of_expression(decl.expression)
        }
    }

    def get_type_of_expression(expr: ExpressionSyntax): Type = {
        val node = MakeNode.expr(expr)
        val links = get_node_links(node)
        if (links.has_type()) {
            links.get_type()
        } else {
            val type = if (expr.kind == SyntaxKind.ArrayCreationExpression) {
                get_type_of_array_creation_expression(expr.arrayCreationExpression[0])
            } else if (expr.kind == SyntaxKind.AssignmentExpression) {
                get_type_of_assignment_expression(expr.assignmentExpression[0])
            } else if (expr.kind == SyntaxKind.BinaryExpression) {
                get_type_of_binary_expression(expr.binaryExpression[0])
            } else if (expr.kind == SyntaxKind.BlockExpression) {
                get_type_of_block_expression(expr.blockExpression[0])
            } else if (expr.kind == SyntaxKind.CallExpression) {
                get_type_of_call_expression(expr.callExpression[0])
            } else if (expr.kind == SyntaxKind.ForExpression) {
                get_type_of_for_expression(expr.forExpression[0])
            } else if (expr.kind == SyntaxKind.GroupExpression) {
                get_type_of_group_expression(expr.groupExpression[0])
            } else if (expr.kind == SyntaxKind.IdentifierName) {
                get_type_of_identifier_name(expr.identifierName[0])
            } else if (expr.kind == SyntaxKind.IfExpression) {
                get_type_of_if_expression(expr.ifExpression[0])
            } else if (expr.kind == SyntaxKind.IndexExpression) {
                get_type_of_index_expression(expr.indexExpression[0])
            } else if (expr.kind == SyntaxKind.LiteralExpression) {
                get_type_of_literal_expression(expr.literalExpression[0])
            } else if (expr.kind == SyntaxKind.MemberAccessExpression) {
                get_type_of_member_access_expression(expr.memberAccessExpression[0])
            } else if (expr.kind == SyntaxKind.NewExpression) {
                get_type_of_new_expression(expr.newExpression[0])
            } else if (expr.kind == SyntaxKind.UnaryExpression) {
                get_type_of_unary_expression(expr.unaryExpression[0])
            } else if (expr.kind == SyntaxKind.UnitExpression) {
                get_type_of_unit_expression(expr.unitExpression[0])
            } else if (expr.kind == SyntaxKind.WhileExpression) {
                get_type_of_while_expression(expr.whileExpression[0])
            } else {
                panic("get_type_of_expression: " + string(expr.kind))
                ErrorType
            }
            links.set_type(type)
        }
    }

    def get_type_of_array_creation_expression(expr: ArrayCreationExpressionSyntax): Type = {
        panic("get_type_of_array_creation_expression")
        ErrorType
    }
    def get_type_of_assignment_expression(expr: AssignmentExpressionSyntax): Type = {
        panic("get_type_of_assignment_expression")
        ErrorType
    }
    def get_type_of_binary_expression(expr: BinaryExpressionSyntax): Type = {
        panic("get_type_of_binary_expression")
        ErrorType
    }
    def get_type_of_block_expression(expr: BlockExpressionSyntax): Type = {
        panic("get_type_of_block_expression")
        ErrorType
    }
    def get_type_of_call_expression(expr: CallExpressionSyntax): Type = {
        panic("get_type_of_call_expression")
        ErrorType
    }
    def get_type_of_for_expression(expr: ForExpressionSyntax): Type = {
        panic("get_type_of_for_expression")
        ErrorType
    }
    def get_type_of_group_expression(expr: GroupExpressionSyntax): Type = {
        panic("get_type_of_group_expression")
        ErrorType
    }
    def get_type_of_identifier_name(expr: IdentifierNameSyntax): Type = {
        panic("get_type_of_identifier_name")
        ErrorType
    }
    def get_type_of_if_expression(expr: IfExpressionSyntax): Type = {
        panic("get_type_of_if_expression")
        ErrorType
    }
    def get_type_of_index_expression(expr: IndexExpressionSyntax): Type = {
        panic("get_type_of_index_expression")
        ErrorType
    }
    def get_type_of_literal_expression(expr: LiteralExpressionSyntax): Type = {
        panic("get_type_of_literal_expression")
        ErrorType
    }
    def get_type_of_member_access_expression(expr: MemberAccessExpressionSyntax): Type = {
        panic("get_type_of_member_access_expression")
        ErrorType
    }
    def get_type_of_new_expression(expr: NewExpressionSyntax): Type = {
        panic("get_type_of_new_expression")
        ErrorType
    }
    def get_type_of_unary_expression(expr: UnaryExpressionSyntax): Type = {
        panic("get_type_of_unary_expression")
        ErrorType
    }
    def get_type_of_unit_expression(expr: UnitExpressionSyntax): Type = {
        panic("get_type_of_unit_expression")
        ErrorType
    }
    def get_type_of_while_expression(expr: WhileExpressionSyntax): Type = {
        panic("get_type_of_while_expression")
        ErrorType
    }


    def get_type_of_type_annotation(typ: TypeAnnotationSyntax): Type =
        get_type_of_name(typ.type)

    def get_type_of_token(token: SyntaxToken): Type =
        get_type_of_string(token.text)

    def get_type_of_string(name: string): Type = {
        if (name == "int") {
            IntType
        } else {
            panic("get_type_of_string: " + name)
            ErrorType
        }
    }

    def get_type_of_name(name: NameSyntax): Type = {
        if (name.kind == SyntaxKind.SimpleName) {
            get_type_of_simple_name(name.simpleName[0])
        } else if (name.kind == SyntaxKind.QualifiedName) {
            get_type_of_qualified_name(name.qualifiedName[0])
        } else {
            panic("get_type_of_name")
            ErrorType
        }
    }

    def get_type_of_simple_name(name: SimpleNameSyntax): Type = {
        if (name.kind == SyntaxKind.IdentifierName) {
            get_type_of_token(name.identifierName[0].identifier)
        } else if (name.kind == SyntaxKind.GenericName) {
            get_type_of_generic_name(name.genericName[0])
        } else {
            panic("get_type_of_simple_name")
            ErrorType
        }
    }

    def get_type_of_generic_name(name: GenericNameSyntax): Type = {
        panic("get_type_of_generic_name")
        ErrorType
    }

    def get_type_of_qualified_name(name: QualifiedNameSyntax): Type = {
        panic("get_type_of_qualified_name")
        ErrorType
    }

    def get_type_of_class_symbol(symbol: Symbol): Type = {
        panic("get_type_of_class_symbol")
        ErrorType
    }
    def get_type_of_method_symbol(symbol: Symbol): Type = {
        panic("get_type_of_method_symbol")
        ErrorType
    }
    def get_type_of_field_symbol(symbol: Symbol): Type = {
        panic("get_type_of_field_symbol")
        ErrorType
    }
    def get_type_of_parameter_symbol(symbol: Symbol): Type = {
        panic("get_type_of_parameter_symbol")
        ErrorType
    }
    def get_type_of_local_symbol(symbol: Symbol): Type = {
        panic("get_type_of_local_symbol")
        ErrorType
    }


    def get_node_id(node: Node): int = {
        if (node.id() != -1) {
            node.id()
        } else {
            if (last_node_id + 1 >= node_links.Length) {
                var newItems = new NodeLinks[(last_node_id + 1) * 2]
                for (i <- 0 to last_node_id) {
                    newItems[i] = node_links[i]
                }
                node_links = newItems
            } else { }

            node_links[last_node_id] = new NodeLinks()
            node.set_id(last_node_id)
            last_node_id = last_node_id + 1
            node.id()
        }
    }

    def get_node_links(node: Node): NodeLinks = {
        val id = get_node_id(node)
        node_links[id]
    }

    def get_symbol_id(symbol: Symbol): int = {
        if (symbol.id != -1) {
            symbol.id
        } else {
            if (last_symbol_id + 1 >= symbol_links.Length) {
                var newItems = new SymbolLinks[(last_symbol_id + 1) * 2]
                for (i <- 0 to last_symbol_id) {
                    newItems[i] = symbol_links[i]
                }
                symbol_links = newItems
            } else { }

            symbol_links[last_symbol_id] = new SymbolLinks()
            symbol.id = last_symbol_id
            last_symbol_id = last_symbol_id + 1
            symbol.id
        }
    }

    def get_symbol_links(symbol: Symbol): SymbolLinks = {
        val id = get_symbol_id(symbol)
        symbol_links[id]
    }

    // convert an inferred SimpleType into the immutable type representation
    def coalesce_type(simple: SimpleType): Type =
        coalesce_type(simple, true)

    def coalesce_type(simple: SimpleType, polarity: bool): Type = {
        if (simple.kind == SimpleTypeKind.Variable) {
            val tv = simple.variable[0]
            val bound = if (polarity) tv.lower_bound() else tv.upper_bound()
            val bound_type = coalesce_type(bound, polarity)
            if (polarity && bound.is_nothing() || bound.is_any()) tv.as_type_var()
            else if (polarity) MakeType.union(tv.as_type_var(), bound_type)
            else MakeType.intersection(tv.as_type_var(), bound_type)
        } else {
            val concrete = simple.concrete[0]
            if (concrete.kind == ConcreteTypeKind.Function) {
                MakeType.function(
                    coalesce_types(concrete.function[0].params, !polarity),
                    coalesce_type(concrete.function[0].returnType, polarity)
                )
            } else if (concrete.kind == ConcreteTypeKind.Record) {
                MakeType.record(coalesce_record(concrete.record[0], polarity))
            } else if (concrete.kind == ConcreteTypeKind.Primitive) {
                MakeType.primitive(concrete.primitive[0].name)
            } else if (concrete.kind == ConcreteTypeKind.Any) {
                MakeType.top
            } else // if (concrete.kind == ConcreteTypeKind.Nothing) {
                MakeType.bottom
            }
    }

    def coalesce_types(simple_types: Array<SimpleType>, polarity: bool): Array<Type> = {
        val types = new Type[simple_types.Length]
        for (x <- 0 to simple_types.Length) {
            types[x] = coalesce_type(simple_types[x], polarity)
        }
        types
    }

    def coalesce_record(record: Record, polarity: bool): RecordType = {
        val fields = new RecordTypeField[record.fields.Length]
        for (x <- 0 to record.fields.Length) {
            fields[x] = coalesce_record_field(record.fields[x], polarity)
        }
        new RecordType(fields)
    }

    def coalesce_record_field(field: RecordField, polarity: bool): RecordTypeField =
        new RecordTypeField(field.name, coalesce_type(field.type, polarity))
}